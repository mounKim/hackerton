# 설계문서

# 1. Introduction

---

## 1.1. Purpose

본 문서의 목적은 연세대학교 강의 “커넥티드플랫폼이론과실제”(CSI4131)에서 Term Project로 진행되는 <Media Web Application 개발> 의 “산플레이어” 팀의 산출물인 “Sanplayer” 에 대해 기술하는것이다.

Sanplayer는 OTT 앱과 유사한 간단한 미디어 웹 앱으로, Sanplayer 개발을 통해 현업에서의 SW 개발 프로세스 및 문화 간접 체험 및 미디어 웹 앱 개발에 이어 빅데이터 시대에서 필요한 데이터 저장/활용/분석 경험을 쌓고자 한다.

## 1.2. Scope

본 문서의 범위는 Sanplayer 개발을 위해 필요한 기능 요구사항(Functional Requirements), 품질 요구사항(Quality Attribute), 제약사항(Constraints)이며, 이를 설명하기 위해 필요한 시스템 컨텍스트(System context)와 용어에 대한 정의를 포함한다.

## 1.3. Defintions and Abbreviations

- ABS **(**Adaptive Bitrate Streaming) : 소스 콘텐츠가 여러 비트레이트로 인코딩되는, HTTP 경유 비디오 스트리밍 방식이다.
- HLS (HTTP Live Streaming) : 표준 HTTP 기반 스트리밍 프로토콜으로, 사용자 네트워크 환경(속도) 에 따라 적합한 콘텐츠를 선택하여 재생할 수 있는 ABS 를 지원한다.
- API (Application Programming Interface) : 응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다.
- React : 메타에서 개발한 오픈소스 자바스크립트 라이브러리로, 사용자 인터페이스 개발을 위해 설계되었다.
- Django : 파이썬으로 작성된 오픈소스 웹 프레임워크로, 웹 애플리케이션이나 API 개발을 위해 설계되었다.

## 1.4. Development Environment

Frontend : [React](https://ko.legacy.reactjs.org/)

Backend : [Django](https://www.djangoproject.com/)

Database : [ElephantSQL](https://www.elephantsql.com/)

# 2**. Architectural Drivers**

---

이 절에서는 미디어 컨텐츠 재생 프로그램의 서버와 데이터베이스 부분의 기능 요구사항 및 비기능 요구사항을 다룬다.

## 2**.1. 기능 요구사항 (Functional Requirements)**

## Backend Server

### 2.1.1. Client로부터 입력 받을 interface 제공

| ID | Requirement  | API ID | Test Case ID |
| --- | --- | --- | --- |
| FR01-1 | backend 서버는 필드에 맞게 파싱된 데이터를 데이터베이스에 저장한다. | BA01-2
BA03-2
BA04-2 | BACK-V-05
BACK-V-07 |
| FR01-2 | client로부터 품질 정보를 전달 받으면, backend 서버는 데이터베이스의 필드에 맞게 파싱한다.

* 데이터베이스의 필드에는 다음 요소들이 포함되어야 한다
- user_id : 사용자
- video_id : 시청한 비디오
- video_url : 비디오 컨텐츠 주소
- bitrate_resource : 제공되는 bitrate 정보
- resolution : width, height
- streaming_type : 스트리밍 종류
- protocol: 비디오 스트리밍 프로토콜 | BA07-2 | BACK-V-12 |
| FR01-3 | client로부터 품질 그래프 정보를 전달 받으면, backend 서버는 데이터베이스의 필드에 맞게 파싱한다.

* 데이터베이스의 필드에는 다음 요소들이 포함되어야 한다
- download_bitrate : 한 세그먼트에서 다운로드한 bitrate
- selected_bitrate : 한 세그먼트에서 선택한 bitrate
- buffering_start : 버퍼링이 시작된 시간
- buffering_end : 버퍼링이 끝난 시간
- segment_duration : 세그먼트 길이 | BA08-2 | BACK-V-14 |

### 2.1.2. 데이터베이스의 데이터 요청에 대한 처리

| ID | Requirement | API ID | Test Case ID |
| --- | --- | --- | --- |
| FR02-1 | frontend 서버로부터 존재하는 비디오 리스트 데이터에 대한 요청을 받으면, backend 서버는 데이터베이스에서 모든 비디오 리스트 정보를 찾아 frontend 서버로 전송한다. | BA01-1 | BACK-V-01 |
| FR02-2 | frontend 서버로부터 특정 비디오의 디테일 정보에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당 비디오의 디테일 정보를 찾아 frontend 서버로 전송한다. | BA02-1 | BACK-V-02
BACK-V-03 |
| FR02-3 | frontend 서버로부터 특정 사용자가 찜한 비디오 리스트 정보에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 비디오 리스트 정보를 찾아 frontend 서버로 전송한다. | BA03-1 | BACK-V-04 |
| FR02-4 | frontend 서버로부터 특정 사용자가 시청한 비디오 리스트 정보에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 비디오 리스트 정보를 찾아 frontend 서버로 전송한다. | BA04-1 | BACK-V-06 |
| FR02-5 | frontend 서버로부터 특정 카테고리별 비디오 리스트 정보에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 비디오 리스트 정보를 찾아 frontend 서버로 전송한다. | BA05-1 | BACK-V-08
BACK-V-09 |
| FR02-6 | frontend 서버로부터 특정 사용자의 비디오 카테고리별 선호도 정보에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 정보를 찾아 frontend 서버로 전송한다. | BA06-1 | BACK-V-10 |
| FR02-7 | frontend 서버로부터 시청한 비디오의 스트리밍 품질 데이터에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 정보를 찾아 frontend 서버로 전송한다.

* 데이터베이스의 필드에는 다음 요소들이 포함되어야 한다. 
- user_id
- video_id
- video_url
- bitrate_resource
- resolution
- streaming_type
- protocol | BA07-1 | BACK-V-11 |
| FR02-8 | frontend 서버로부터 시청한 비디오의 스트리밍 품질  그래프 데이터에 대한 요청을 받으면, backend 서버는 데이터베이스에서 해당하는 정보를 찾아 frontend 서버로 전송한다.

* 데이터베이스의 필드에는 다음 요소들이 포함되어야 한다.
- download_bitrate
- selected_bitrate
- buffering_start
- buffering_end
- segment_duration | BA08-1 | BACK-V-13 |

## Frontend

### 2.1.3. 로그인 이전

| ID | Page Name | Requirement | Test Case ID |
| --- | --- | --- | --- |
| FR03-1 | 로그인 | 사용자로부터 사용자 ID, Password를 입력받아 서버의 서버에 등록되었는지 여부를 확인해 등록되어 있다면 로그인을 수행하고 <미디어 컨텐츠 목록 조회(카테고리별)> Page로 이동한다. | Front-ST-01 |
| FR03-2 | 회원가입 | 사용자로부터 이메일, 사용자 ID, Password를 입력받아 사용할 수 있는 ID라면 서버에 정보를 등록하고, 로그인을 수행하고, <미디어 컨텐츠 목록 조회(카테고리별)> Page로 이동한다. | Front-ST-02 |
| FR03-3 | 회원가입 | 사용자로부터 입력받은 이메일, 사용자 ID, Password가 유효한 형식인지 확인하고, 유효한 형식일 때에만 회원가입 요청을 보낼 수 있도록 한다. | Front-ST-03 |

### 2.1.4. 미디어 컨텐츠 목록 조회

| ID | Page Name | Requirement | Test Case ID |
| --- | --- | --- | --- |
| FR04-1 | 미디어 컨텐츠
목록 조회
(카테고리별) | 사용자로부터 <미디어 컨텐츠 목록 조회(전체)> 요청을 받으면 <컨텐츠 목록 조회(전체)> Page로 이동한다. | Front-ST-04 |
| FR04-2 | 미디어 컨텐츠
목록 조회
(카테고리별) | 사용자로부터 <재생기록, 좋아요한 컨텐츠 목록 조회> 요청을 받으면 <재생기록, 좋아요한 컨텐츠 목록 조회> Page로 이동한다. | Front-ST-05 |
| FR04-3 | 미디어 컨텐츠
목록 조회
(카테고리별) | 사용자의 ID에 따라 미디어 컨텐츠의 카테고리 종류별 추천도와 미디어 컨텐츠 목록을 서버로부터 받아오고, 추천도에 따라 각 카테고리 GUI(산)의 크기를 조절한다. | Front-ST-06 |
| FR04-4 | 미디어 컨텐츠
목록 조회
(카테고리별) | 사용자로가 카테고리를 선택하면 미디어 컨텐츠 목록을 출력한다. | Front-ST-07 |
| FR04-5 | 미디어 컨텐츠
목록 조회
(카테고리별) | 사용자로부터 특정 미디어 컨텐츠에 대한 <미디어 컨텐츠 재생> 요청을 받으면 해당 컨텐츠의 <미디어 컨텐츠 재생> Page로 이동한다. | Front-ST-08 |
| FR04-6 | 미디어 컨텐츠
목록 조회
(전체) | 서버로부터 전체 미디어 컨텐츠 목록을 가져와 카테고리별로 정렬하여 출력한다. | Front-ST-04 |
| FR04-7 | 미디어 컨텐츠
목록 조회
(전체) | 사용자로부터 <미디어 컨텐츠 목록 조회(카테고리별)> 요청을 받으면 <컨텐츠 목록 조회(카테고리별)> Page로 이동한다. | Front-ST-07 |
| FR04-8 | 미디어 컨텐츠
목록 조회
(전체) | 사용자로부터 <재생기록, 좋아요한 컨텐츠 목록 조회> 요청을 받으면 <재생기록, 좋아요한 컨텐츠 목록 조회> Page로 이동한다. | Front-ST-05 |
| FR04-9 | 미디어 컨텐츠
목록 조회
(전체) | 사용자로부터 특정 미디어 컨텐츠에 대한 <미디어 컨텐츠 재생> 요청을 받으면 해당 컨텐츠의 <미디어 컨텐츠 재생> Page로 이동한다. | Front-ST-08 |

### 2.1.5. 미디어 컨텐츠 재생

| ID | Page Name | Requirement | Test Case ID |
| --- | --- | --- | --- |
| FR05-1 | 미디어 컨텐츠
재생 | 사용자로부터 <미디어 컨텐츠 목록 조회(카테고리별)> 요청을 받으면 <컨텐츠 목록 조회(카테고리별)> Page로 이동한다. | Front-ST-07 |
| FR05-2 | 미디어 컨텐츠
재생 | 사용자로부터 <재생기록, 좋아요한 컨텐츠 목록 조회> 요청을 받으면 <재생기록, 좋아요한 컨텐츠 목록 조회> Page로 이동한다. | Front-ST-05 |
| FR05-3 | 미디어 컨텐츠
재생 | 서버로부터 현재 미디어 컨텐츠의 링크, 이름, 카테고리, 재생ID를 받아와 미디어컨텐츠를 GUI에 로드한다. | Front-ST-08 |
| FR05-4 | 미디어 컨텐츠
재생 | 현재 미디어 컨텐츠 재생/중단 기능을 지원한다. | Front-ST-09 |
| FR05-5 | 미디어 컨텐츠
재생 | 현재 미디어 컨텐츠를 5초 건너뛰기/돌아가기 하는 기능을 지원한다. | Front-ST-10 |
| FR05-6 | 미디어 컨텐츠
재생 |  현재 미디어 컨텐츠의 음성 볼륨 조절 기능을 지원한다. | Front-ST-11 |
| FR05-7 | 미디어 컨텐츠
재생 |  현재 미디어 컨텐츠의 재생 속도 조절 기능을 지원한다. | Front-ST-12 |
| FR05-8 | 미디어 컨텐츠
재생 | 미디어 컨텐츠 링크로부터 이용 가능한 해상도를 받아와 해상도 설정 기능을 지원한다. | Front-ST-13 |
| FR05-9 | 미디어 컨텐츠
재생 | 사용자로부터 좋아요/좋아요 해제 요청을 받으면 현재 미디어 컨텐츠의 ID를 서버로 전송해 좋아요한 목록에 추가한다. | Front-ST-14 |
| FR05-10 | 미디어 컨텐츠
재생 | 현재 미디어 컨텐츠의 스트리밍 품질 데이터를 서버로 전달한다.

*전달하는 스트리밍 품질 데이터는 아래와 같다.
- downloadBitrate
- selectedBitrate
- bufferingStart
- bufferingEnd
- segmentDuration
- BitrateResource
- Resolution(Width X Height)
- StreamType | Front-ST-06 |
| FR05-11 | 미디어 컨텐츠
재생 | 현재 미디어 컨텐츠의 재생기록을 서버로 전달한다. | Front-ST-06 |
| FR05-12 | 미디어 컨텐츠
재생 | 현재 미디어 컨텐츠와 연관된 다른 미디어 컨텐츠의 목록을 서버에서 전달받아 출력한다. | Front-ST-06 |
| FR05-13 | 미디어 컨텐츠
재생 | 사용자로부터 현재 미디어 컨텐츠와 연관된 다른 미디어 컨텐츠에 대한 <미디어 컨텐츠 재생> 요청을 받으면 해당 컨텐츠의 <미디어 컨텐츠 재생> Page로 이동한다. | Front-ST-15 |

### 2.1.6. 재생기록, 좋아요한 컨텐츠 목록 조회

| ID | Page Name | Requirement | Test Case ID |
| --- | --- | --- | --- |
| FR06-1 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 사용자로부터 <미디어 컨텐츠 목록 조회(카테고리별)> 요청을 받으면 <컨텐츠 목록 조회(카테고리별)> Page로 이동한다. | Front-ST-04 |
| FR06-2 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 사용자로부터 로그아웃 요청을 받으면 로그아웃을 수행하고, <로그인> Page로 이동한다. | Front-ST-16 |
| FR06-3 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 서버로부터 현재 사용자의 미디어 컨텐츠 재생 기록 정보를 받아 출력한다. | Front-ST-05 |
| FR06-4 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 서버로부터 현재 사용자의 좋아요한 미디어 컨텐츠 목록을 받아 출력한다. | Front-ST-05 |
| FR06-5 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 사용자로부터 미디어 컨텐츠에 대한 <미디어 컨텐츠 재생> 요청을 받으면 해당 컨텐츠의 <미디어 컨텐츠 재생> Page로 이동한다. | Front-ST-17 |
| FR06-6 | 재생기록, 좋아요한 컨텐츠 목록 조회 | 사용자로부터 <미디어 품질 데이터 목록 조회> 요청을 받으면 <미디어 품질 데이터 목록 조회> Page로 이동한다. | Front-ST-18 |

### 2.1.7. 미디어 품질 데이터 조회

| ID | Page Name | Requirement | Test Case ID |
| --- | --- | --- | --- |
| FR07-1 | 미디어 품질
데이터 목록 조회 | 사용자로부터 <재생기록, 좋아요한 컨텐츠 목록 조회> 요청을 받으면 <재생기록, 좋아요한 컨텐츠 목록 조회> Page로 이동한다. | Front-ST-19 |
| FR07-2 | 미디어 품질
데이터 목록 조회 | 서버로부터 미디어 품질 데이터 목록을 받아 표 형식으로 출력한다.

*이 때 출력하는 항목들은 아래와 같다.
- Session Id
- URL
- Playback Date
- Bitrate Resource
- Resolution(Width X Height)
- Stream Type
- Protocol | Front-ST-18 |
| FR07-3 | 미디어 품질
데이터 목록 조회 | 사용자가 미디어 품질 데이터 목록 중 원하는 항목을 선택하면, 해당 미디어 품질 데이터의 <미디어 품질 데이터 조회> Page로 이동한다. | Front-ST-20 |
| FR07-4 | 미디어 품질
데이터 조회 | 사용자로부터 <재생기록, 좋아요한 컨텐츠 목록 조회> 요청을 받으면 <재생기록, 좋아요한 컨텐츠 목록 조회> Page로 이동한다. | Front-ST-19 |
| FR07-5 | 미디어 품질
데이터 조회 | 사용자로부터 <미디어 품질 데이터 목록 조회> 요청을 받으면 <미디어 품질 데이터 목록 조회> Page로 이동한다. | Front-ST-21 |
| FR07-6 | 미디어 품질
데이터 조회 | 현재 미디어 품질 데이터를 그래프의 형식으로 표현한다.

*이 때 아래의 항목들을 y축 값으로 사용하고, x축 값으로는 시간을 사용한다.
- selected_bitrate
- download_bitrate
- buffering_start
- buffering_end | Front-ST-20 |

# 3. Architecture Overview

---

## 3.1. **System Context**

![System Context](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fe6845cb-2b3c-48a8-b43c-9b9a11761b7a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-04_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_1.02.45.png)

System Context

미디어 재생 뿐만 아니라 미디어 목록과 품질 데이터를 시각적으로 제공하는 기능을 담당하는 Frontend와 품질 정보와 재생 요청, 재생 기록 등을 전달 받아 Database에 저장하고, Frontend와 Database간의 데이터의 전송 및 삭제 요청을 처리하는 기능을 담당하는 Backend 서버로 분리하여 구현한다.

## 3.2. Static Perspective

Static Perspective의 Usecase Diagram은 다음과 같다.

![Static Perspective Usecase Diagram](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bcd00a56-0a50-421c-bd4c-2bf9a5222d89/usecasediagram.png)

Static Perspective Usecase Diagram

## 3.3. Dynamic Perspective

사용자의 요청이 어떤 것인지에 따라 다르게 작동한다. Frontend와 Backend 서버의  통신 형태에 따라 아래와 같은 세 가지 형태로 구분할 수 있다.

### 3.3.1. 서버와의 통신이 필요없는 경우

![서버와의 통신이 필요없는 경우](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f85ded94-3696-46de-830d-1035fad7e27a/dynamic1.png)

서버와의 통신이 필요없는 경우

서버와의 통신이 필요없는 경우에는 Frontend 단에서 모든 요청을 처리하기 때문에 Backend, Database와 상호작용이 일어나지 않는다.

아래와 같은 Functional Requirement들이 서버와의 통신이 필요없는 경우이다.

FR03-3, FR04-1, FR04-2, FR04-4, FR04-5, FR04-7, FR04-8, FR04-9, FR05-1, FR05-2, FR05-4, FR05-5, FR05-6, FR05-7, FR05-8, FR05-13, FR06-1, FR06-5, FR06-6, FR07-1, FR07-3, FR07-4, FR07-5

### 3.3.2. 서버와의 통신이 한 번 필요한 경우

![서버와의 통신이 한 번 필요한 경우](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0b70a606-2eb8-4f38-83b9-2d01e8259017/dynamic2.png)

서버와의 통신이 한 번 필요한 경우

서버와의 통신이 한 번 필요한 경우에는 Frontend에서 요청을 받아 Backend로 API 요청을 보내고, Backend단에서 Database로 query를 통해 데이터를 전달 받아 가공 후 Frontend로 전달한다.

아래와 같은 Functional Requirement들이 서버와의 통신이 한 번 필요한 경우이다.

FR03-1, FR03-2, FR05-3, FR05-9, FR05-10, FR05-11, FR05-12, FR06-2, FR06-3, FR06-4, FR07-2, FR07-6

### 3.3.3. 서버와의 통신이 여러 번 필요한 경우

![서버와의 통신이 여러 번 필요한 경우](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c36bc206-c28a-4a76-bf90-a03c17aed11a/dynamic3.png)

서버와의 통신이 여러 번 필요한 경우

서버와의 통신이 여러 번 필요한 경우에는 Frontend에서 Backend로 API 요청을 여러 번 보낸다. 데이터베이스에 있는 정보를 기반으로 API를 호출해야 할 경우가 이 경우에 속한다.

아래와 같은 Functional Requirement들이 서버와의 통신이 여러 번 필요한 경우이다.

FR04-3, FR04-6

# 4. Database Design

---

Sanplayer의 Database Schema는 다음과 같다. 

![Database Schema](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56a8c5c5-bc81-4eb7-b08a-559913c9d2cc/san_player_db.drawio.png)

Database Schema

## 4.1 Entity Description

| entity name | Description |
| --- | --- |
| User | django.contrib.auth.models 에서 제공하는 모델
- username : user의 id
- password : user의 password (django 에서 자동으로 hashed 값으로 저장) |
| VideoList | 제공하는 비디오들의 object 정보를 저장하는 모델
- video_url : 비디오의 url
- video_name : 비디오의 제목
- image : 비디오의 썸네일 |
| VideoCategory | 제공하는 카테고리 목록들의 이름을 저장하는 모델
- category : 카테고리 이름 |
| UserCategory | user의 모든 카테고리별 추천도를 저장하는 모델
- score {n} : n번째 카테고리에 대한 추천도 (n = 1 … 8) |
| SaveVideo | user가 찜한 비디오 목록들을 저장하는 모델 |
| WatchedVideo | user가 시청한 비디오 목록들을 저장하는 모델
- updated_at : user가 비디오를 시청한 시간 (클릭한 시간으로 자동 저장) |
| StreamingQuality | user가 시청한 비디오의 기본 streaming quality 정보를 저장하는 모델
- video_url : 비디오의 url
- bitrate_resource : 가능한 bitrate들
- resolution : 가능한 해상도들
- streaming_type : 비디오의 streaming type
- protocol : 비디오 재생 프로토콜 |
| Graph | 기본 streaming quality 정보가 저장된 비디오의 실제 실시간 streaming quality 정보를 저장하는 모델
- download_bitrate : 미디어를 download 하고 있는 bitrate
- selected_bitrate : 현재 재생중인 level의 bitrate
- buffering_start : 버퍼링이 시작된 시간
- buffering_end : 버퍼링이 끝난 시간
- segment_duration : 세그먼트 길이 |

## 4.2 Relation Description

| relation | type | Description |
| --- | --- | --- |
| VideoList - VideoCategory | m:n | 각 비디오는 여러 개의 카테고리를 가질 수 있고, 각 카테고리는 여러 개의 비디오를 가질 수 있다. |
| User - UserCategory | 1:1 | 모든 User는 하나의 UserCategory를 갖는다. |
| SaveVideo - User | 1:1 | 저장된 비디오는 시청한 user의 정보를 가져야하므로, SaveVideo의 entry는 하나의 User를 갖는다. |
| SaveVideo - VideoList | 1:1 | 저장된 비디오는 시청한 비디오의 정보를 가져야하므로, SaveVideo의 entry는 하나의 VideoList를 갖는다. |
| WatchedVideo - User | 1:1 | 시청한 비디오는 시청한 user의 정보를 가져야하므로, WatchedVideo의 entry는 하나의 User를 갖는다. |
| WatchedVideo - VideoList | 1:1 | 시청한 비디오는 시청한 비디오의 정보를 가져야하므로, WatchedVideo의 entry는 하나의 VideoList를 갖는다. |
| StreamingQuality - User | 1:1 | 스트리밍 기본 정보는 user별로 저장되기 위해 비디오를 재생을 한 user의 정보를 가져야하므로, StreamingQuality의 entry는 하나의 User를 갖는다. |
| StreamingQuality - WatchedVideo | 1:1 | 스트리밍 기본 정보는 어떤 비디오를 재생하다가 발생된 정보인지 저장하기 위해 시청한 비디오의 정보를 가져야하므로, StreamingQuality의 entry는 하나의 WatchedVideo를 갖는다. |
| Graph - StreamingQuality | 1:1 | 실시간 스트리밍 정보는 스트리밍 기본 정보가 저장된 비디오에 속하는 데이터이기 때문에 스트리밍 기본 정보의 정보를 가져야하므로, Graph의 entry는 하나의 StreamingQuality를 갖는다. |

# 5. Etc

## 5.1. UI Design

Flat Minimalism Design을 디자인 철학으로 만든 초기 디자인은 아래와 같은 형식이었다. 

![Sanplayer 로고](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9f0a0ed9-8c6e-4dd8-939a-67af33852c10/logo.png)

Sanplayer 로고

![Sanplayer 초기 디자인](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4923142c-290d-479f-9c01-ed4adb9db5ae/pre_design.png)

Sanplayer 초기 디자인

---

### 해야 할 것들

설계문서

1, 주황색 부분 채우기

2, 제목 한글/영어 형식 통일

코드

~~1, mypage 들어가는 아이콘 바꾸기 << 그냥 마이페이지에서 쓰고있는 버튼 디자인이 나을듯~~

했음

2, 

---

## 참고할 것들

### Figma 첫 설계도

https://www.figma.com/file/nSm2WsjCGudGcBEOS8CB2z/Untitled?type=design&node-id=0-1&t=MDyx6FnGynCuD64y-0

### Doc Guide

https://github.com/Hosang10Lee/opennotes/blob/main/termproject/Documentation_Guide.md

### Sample Docs

https://github.com/Hosang10Lee/opennotes/tree/main/termproject/sample-docs